<!-- DO NOT MODIFY -->
<!-- This file was autogenerated by build-docs.ts -->
<!-- Edit the docstring in index.ts and regenerate -->
<!-- rather than editing this file directly. -->
# unified-latex-util-macros

## What is this?

Functions to manipulate macros and their arguments in a `unified-latex` Abstract Syntax Tree (AST).

## When should I use this?

If you want to expand macros or get a list of macros defined via `\newcommand`.

# Functions

## `createMacroExpander(substitution)`

A factory function. Given a macro definition, creates a function that accepts
the macro's arguments and outputs an Ast with the contents substituted (i.e.,
it expands the macro).

```typescript
function createMacroExpander(
  substitution: Ast.Node[]
): (macro: Ast.Macro) => Ast.Node[];
```

**Parameters**

| Param        | Type         |
| :----------- | :----------- |
| substitution | `Ast.Node[]` |

## `createMatchers()`



```typescript
function createMatchers(): {
  isHash: (node: Ast.Node) => boolean;
  isNumber: (node: Ast.Node) => boolean;
  splitNumber: (
    node: Ast.String
  ) =>
    | { number: number; rest: { type: string; content: string } }
    | { number: number; rest?: undefined };
};
```

## `expandMacros(tree, macros)`

Expands macros in `ast` as specified by `macros`.
Each macro in `macros` should provide the substitution AST (i.e., the AST with the #1, etc.
in it). This function assumes that the appropriate arguments have already been attached
to each macro specified. If the macro doesn't have it's arguments attached, its
contents will be wholesale replaced with its substitution AST.

```typescript
function expandMacros(
  tree: Ast.Ast,
  macros: { name: string; substitution: Ast.Node[] }[]
): void;
```

**Parameters**

| Param  | Type                              |
| :----- | :-------------------------------- |
| tree   | `Ast.Ast`                         |
| macros | <span color='gray'>Omitted</span> |

## `newcommandMacroToName(node)`

Get the name of the macro defined with `\newcommand`/`\renewcommand`/etc..

```typescript
function newcommandMacroToName(node: Ast.Macro): string;
```

**Parameters**

| Param | Type        |
| :---- | :---------- |
| node  | `Ast.Macro` |

## `newcommandMacroToSpec(node)`

Compute the xparse argument signature of the `\newcommand`/`\renewcommand`/etc. macro.

```typescript
function newcommandMacroToSpec(node: Ast.Macro): string;
```

**Parameters**

| Param | Type        |
| :---- | :---------- |
| node  | `Ast.Macro` |

## `newcommandMacroToSubstitutionAst(node)`

Returns the AST that should be used for substitution. E.g.,
`\newcommand{\foo}{\bar{#1}}` would return `\bar{#1}`.

```typescript
function newcommandMacroToSubstitutionAst(node: Ast.Macro): Ast.Node[];
```

**Parameters**

| Param | Type        |
| :---- | :---------- |
| node  | `Ast.Macro` |

## `parseMacroSubstitutions(ast)`

Parse for macro substitutions. For example, in "\foo{#1}", the `#1`
is recognized as a `HashNumber` (`{type: "hash_number"}`). Double hashes
are automatically replaced with their single-hash substitutions.

The resulting AST is ready for substitutions to be applied to it.

```typescript
function parseMacroSubstitutions(ast: Ast.Node[]): (Ast.Node | HashNumber)[];
```

**Parameters**

| Param | Type         |
| :---- | :----------- |
| ast   | `Ast.Node[]` |
